#include "monster_builder.h" // Generated by `flatcc`.
#include "monster_reader.h"
#include <stdio.h>

#define test_assert(x) do { if (!(x)) { assert(0); return -1; }} while(0)

#undef ns
#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(MyGame_Sample, x) // Specified in the schema.

int create_message_bottom_up(flatcc_builder_t *B)
{
    int code = -128; 

    // Code Table
    ns(CodeTable_ref_t) codetable = ns(CodeTable_create(B, code));

    // Union with Code Table
    ns(MessageData_union_ref_t) data = ns(MessageData_as_CodeData(codetable));

    // Create the Message
    ns(Message_create_as_root(B, data));

    return 0;
}

int access_message_buffer(const void *buffer, int expected_code)
{
    ns(Message_table_t) message = ns(Message_as_root(buffer));
    test_assert(message != 0);

    int code = 0;
    if (ns(Message_data_type(message) == ns(MessageData_CodeData))) {
        ns(CodeTable_table_t) data = (ns(CodeTable_table_t)) ns(Message_data(message));
        code = ns(CodeTable_code(data));
        test_assert(code == expected_code);
    }
    else {
        test_assert(0);
    }

    printf("WE ARE ABLE TO READ IT, IT IS WELL FORMED\n");
    return 0;
}

#define TABLE_PREDETERMINED_MSG  {4, 0, 0, 0, 230, 255, 255, 255, 8, 0, 0, 0, 1, 0, 0, 0, 248, 255, 255, 255, 128, 255, 255, 255, 6, 0, 8, 0, 4, 0, 8, 0, 9, 0, 8, 0, 4, 0, 0, 0}

int generate_template(void)
{
    flatcc_builder_t builder;
    void *buf;
    size_t size;

    flatcc_builder_init(&builder);
    test_assert(0 == create_message_bottom_up(&builder));
    buf = flatcc_builder_finalize_aligned_buffer(&builder, &size);
    access_message_buffer(buf, -128);


    printf("{");
    for (size_t i = 0; i < size; i++) {
        printf("%u, ", (unsigned) ((uint8_t *)buf)[i]);
    }
    printf("}\n");

    printf("MY TEMPLATE WAS GENERATED of size %zu\n", size);
    test_assert(size == 40);


    // Check it is as expected
    uint8_t buffer[40] = TABLE_PREDETERMINED_MSG;
    for (size_t i = 0; i < size; i++) {
        test_assert((((uint8_t *)buf)[i]) == buffer[i]);
    }

    flatcc_builder_aligned_free(buf);

    printf("MATCHES PREDETERMINED ARR\n");
    return 0;
}

typedef struct {
    uint8_t buffer[40] __attribute__ ((aligned (8))); 
} builder_t;

int run_test(void) {
    builder_t msg = {TABLE_PREDETERMINED_MSG};
    ns(Message_table_t) msg_table_root = ns(Message_as_root(msg.buffer));
    ns(CodeTable_table_t) table_ptr = ns(Message_data(msg_table_root));

    (void) table_ptr;
    // Uncomment to test changing the `code` integer
    // const int32_t *ptr = ns(CodeTable_code_get_ptr(table_ptr));
    // printf("PTR is %p\n", ptr);
    // int32_t *nonconst_ptr = (int32_t *) ptr;
    // *nonconst_ptr = -500;
    // access_message_buffer(msg.buffer, -500);

    return 0;
}

int main(int argc, char *argv[])
{
    (void) argc;
    (void) argv;
    generate_template();
    run_test();

    return 0;
}
